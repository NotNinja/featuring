{"version":3,"file":"featuring.js","sources":["../src/featuring.js","../index.js"],"sourcesContent":["/*\n * Copyright (C) 2017 Alasdair Mercer, !ninja\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\n/**\n * Contains feature mappings for each initialized scope.\n *\n * A feature mapping won't exist for a scope until {@link featuring.init} is called for it.\n *\n * @private\n * @type {Object.<string, Object.<string, boolean>>}\n */\nvar features = {};\n\n/**\n * Contains all features mapped to the global/shared scope.\n *\n * This will be <code>null</code> until {@link featuring.init} is called without a scope specified (or when it is\n * <code>null</code>).\n *\n * @private\n * @type {?Object.<string, boolean>}\n */\nvar globalFeatures = null;\n\n/**\n * Creates an instance of {@link Feature} for the specified <code>name</code> within the <code>scope</code> provided.\n *\n * <code>name</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * If <code>scope</code> is <code>null</code> it will default to a global/shared scope and, like <code>name</code>,\n * <code>scope</code> is case sensitive.\n *\n * @param {string} name - the name to be used\n * @param {?string} scope - the scope to be used (may be <code>null</code>, defaults to global/shared)\n * @private\n * @constructor\n */\nfunction Feature(name, scope) {\n  /**\n   * The name of this {@link Feature}.\n   *\n   * @private\n   * @type {string}\n   * @memberof Feature#\n   */\n  this._name = name;\n\n  /**\n   * The scope of this {@link Feature}.\n   *\n   * If <code>null</code>, the global/shared scope should be used.\n   *\n   * @private\n   * @type {?string}\n   * @memberof Feature#\n   */\n  this._scope = scope;\n}\n\nFeature.prototype = {\n\n  constructor: Feature,\n\n  /**\n   * Returns whether this {@link Feature} is active within its scope.\n   *\n   * This method will only return <code>true</code> if the scope for this {@link Feature} has been initialized and\n   * contains the name of this {@link Feature}.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring.init([ 'FOO', 'BAR' ], 'example');\n   *\n   * featuring('FOO', 'example').active();\n   * //=> true\n   * featuring('BAR', 'example').active();\n   * //=> true\n   * featuring('foo', 'example').active();\n   * //=> false\n   * featuring('FOO').active();\n   * //=> false\n   *\n   * featuring.init([ 'FIZZ', 'BUZZ' ]);\n   *\n   * featuring('FIZZ', 'example').active();\n   * //=> false\n   * featuring('BUZZ').active();\n   * //=> true\n   * </pre>\n   * @return {boolean} <code>true</code> if this {@link Feature} is active; otherwise <code>false</code>.\n   * @public\n   * @memberof Feature#\n   */\n  active: function() {\n    var target = getMap(this._scope);\n\n    return Boolean(target && target[this._name]);\n  },\n\n  /**\n   * Returns a version of this {@link Feature} that is bound to the specified <code>scope</code>.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring.init([ 'FOO', 'BAR' ], 'example');\n   *\n   * var feature = featuring('FOO');\n   *\n   * feature.active();\n   * //=> false\n   * feature.using('example').active();\n   * //=> true\n   * </pre>\n   * @param {?string} scope - the scope to be used (may be <code>null</code>, defaults to global/shared)\n   * @return {Feature} A version of this {@link Feature} for <code>scope</code>.\n   * @public\n   * @memberof Feature#\n   */\n  using: function(scope) {\n    return new Feature(this._name, scope);\n  },\n\n  /**\n   * Verifies that this {@link Feature} is active within its scope and throws and error if it is not.\n   *\n   * This method is useful for fail-fast sitations where you simply want your code to break when this {@link Feature} is\n   * not active.\n   *\n   * This {@link Feature} is only considered active if its scope has been initialized and contains its name.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring.init([ 'FOO', 'BAR' ], 'example');\n   *\n   * featuring('FOO', 'example').verify();\n   * try {\n   *   featuring('FIZZ', 'example').verify();\n   * } catch (error) {\n   *   console.error(error);\n   *   //=> \"Error: \"FIZZ\" feature in \"example\" scope is not active\"\n   * }\n   * </pre>\n   * @return {Feature} A reference to this {@link Feature} for chaining purposes.\n   * @throws {Error} If this {@link Feature} is not active.\n   * @public\n   * @memberof Feature#\n   */\n  verify: function() {\n    var formattedName, formattedScope;\n\n    if (!this.active()) {\n      formattedName = '\"' + this._name + '\"';\n      formattedScope = isString(this._scope) ? '\"' + this._scope + '\"' : 'global';\n\n      throw new Error(formattedName + ' feature in ' + formattedScope + ' scope is not active');\n    }\n\n    return this;\n  },\n\n  /**\n   * Invokes the specified function only when this {@link Feature} is active within its scope.\n   *\n   * This method is often preferred over using {@link Feature#active} within an <code>if</code> expression when wrapping\n   * large code. It helps prevent potential scoping issues (e.g. from variable hoisting) and can even be simpler to\n   * replace with IIFEs, when taking that route.\n   *\n   * This {@link Feature} is only considered active if its scope has been initialized and contains its name.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring.init([ 'FOO', 'BAR' ], 'example');\n   *\n   * featuring('FOO', 'example').when(function() {\n   *   // ...\n   * });\n   * featuring('BAR').when(function() {\n   *   // Never called\n   * });\n   * </pre>\n   * @param {Function} func - the function to be invoked when this {@link Feature} is active\n   * @return {Feature} A reference to this {@link Feature} for chaining purposes.\n   * @public\n   * @memberof Feature#\n   */\n  when: function(func) {\n    if (this.active()) {\n      func();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Returns a {@link Feature} for the specified <code>name</code> within the <code>scope</code> provided.\n *\n * <code>name</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>name</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method will <i>always</i> return an instance, even if <code>name</code> does not match a known/enabled feature,\n * as it is expected that the methods on the returned {@link Feature} instance will be used to check its state.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring('FOO', 'example').active();\n * //=> true\n * try {\n *   featuring('foo', 'example').verify();\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: \"foo\" feature in \"example\" scope is not active\"\n * }\n * featuring('BAR').when(function() {\n *   // Never called\n * });\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring('FIZZ', 'example').active();\n * //=> false\n * featuring('BUZZ').active();\n * //=> true\n *\n * featuring('BAR').using('example').active();\n * //=> true\n * </pre>\n * @param {string} name - the name of the feature\n * @param {string} [scope] - the scope of the feature (may be <code>null</code>, defaults to global/shared)\n * @return {Feature} A {@link Feature} for <code>name</code> and <code>scope</code>.\n * @public\n */\nfunction featuring(name, scope) {\n  return new Feature(name, scope);\n}\n\n/**\n * Returns whether <b>all</b> of the named features are active within the specified <code>scope</scope>.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method will only return <code>true</code> if <code>scope</code> has been initialized and contains all\n * <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.active('FOO', 'example');\n * //=> true\n * featuring.active([ 'FOO', 'BAR' ], 'example');\n * //=> true\n * featuring.active([ 'FOO', 'BUZZ' ], 'example');\n * //=> false\n * featuring.active([ 'foo', 'bar' ], 'example');\n * //=> false\n * featuring.active('FOO');\n * //=> false\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.active('FIZZ', 'example');\n * //=> false\n * featuring.active([ 'FIZZ', 'BUZZ' ]);\n * //=> true\n *\n * featuring.active([]);\n * //=> true\n * </pre>\n * @param {string|string[]} names - the names of the features to be checked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @return {boolean} <code>true</code> if all of the features are active or <code>names</code> is empty; otherwise\n * <code>false</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.active = function(names, scope) {\n  if (isString(names)) {\n    names = [ names ];\n  }\n\n  return names.every(function(name) {\n    var feature = new Feature(name, scope);\n\n    return feature.active();\n  });\n};\n\n/**\n * Returns whether <b>any</b> of the named features are active within the specified <code>scope</scope>.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method will return <code>true</code> if <code>scope</code> has been initialized and contains at least one of\n * <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.active.any('FOO', 'example');\n * //=> true\n * featuring.active.any([ 'FOO', 'BAR' ], 'example');\n * //=> true\n * featuring.active.any([ 'FOO', 'BUZZ' ], 'example');\n * //=> true\n * featuring.active.any([ 'foo', 'bar' ], 'example');\n * //=> false\n * featuring.active.any('FOO');\n * //=> false\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.active.any('FIZZ', 'example');\n * //=> false\n * featuring.active.any([ 'FIZZ', 'BUZZ' ]);\n * //=> true\n *\n * featuring.active.any([]);\n * //=> false\n * </pre>\n * @param {string|string[]} names - the names of the features to be checked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @return {boolean} <code>true</code> if any of the features are active; otherwise <code>false</code>.\n * @public\n * @static\n * @memberof featuring.active\n */\nfeaturing.active.any = function(names, scope) {\n  if (isString(names)) {\n    names = [ names ];\n  }\n\n  return names.some(function(name) {\n    var feature = new Feature(name, scope);\n\n    return feature.active();\n  });\n};\n\n/**\n * An alias for the {@link featuring.active.any} method.\n *\n * @param {string|string[]} names - the names of the features to be checked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @return {boolean} <code>true</code> if any of the features are active; otherwise <code>false</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.anyActive = featuring.active.any;\n\n/**\n * Returns the names of all of the active features within the specified <code>scope</scope>.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. <code>scope</code> is case\n * sensitive.\n *\n * This method will only return the names of features that are active within <code>scope</code> if it has been\n * initialized. Otherwise, the returned array will be empty. It is not guaranteed that the feature names will be\n * returned in the same order in which they were passed to {@link featuring.init}.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.get('example');\n * //=> []\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.get('example');\n * //=> [ \"FOO\", \"BAR\" ]\n * featuring.get();\n * //=> []\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.get();\n * //=> [ \"FIZZ\", \"BUZZ\" ]\n * </pre>\n * @param {string} [scope] - the scope for which the names of all active features are to be returned (may be\n * <code>null</code>, defaults to global/shared)\n * @return {string[]} The names of all features active within <code>scope</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.get = function(scope) {\n  var names = [];\n\n  each(getMap(scope), function(value, name) {\n    names.push(name);\n  });\n\n  return names;\n};\n\n/**\n * Initializes the specified <code>scope</code> with all of the named features.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * Obviously, this method should really be called before other methods, however, it can only be called once per scope.\n * Any attempts to initialize the same scope more than once will result in an error being thrown. This is done to\n * protect the immutability of the library. It's possible to check whether a scope has already been initialized via\n * {@link featuring.initialized}, if required to do so.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.active('FOO', 'example');\n * //=> false\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n * try {\n *   featuring.init([ 'FIZZ', 'BUZZ' ], 'example');\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: \"example\" scope features have already been initialized\"\n * }\n *\n * featuring.active([ 'FOO', 'BAR' ], 'example');\n * //=> true\n *\n * featuring.active('FIZZ');\n * //=> false\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n * try {\n *   featuring.init([ 'FOO', 'BAR' ]);\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: Global features have already been initialized\"\n * }\n *\n * featuring.active([ 'FIZZ', 'BUZZ' ]);\n * //=> true\n * </pre>\n * @param {string|string[]} names - the name of the features to be activated\n * @param {string} [scope] - the scope to be initialized with the active features (may be <code>null</code>, defaults to\n * global/shared)\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @throws {Error} If the features for <code>scope</code> have already been initialized.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.init = function(names, scope) {\n  if (isString(scope)) {\n    if (features[scope]) {\n      throw new Error('\"' + scope + '\" scope features have already been initialized');\n    }\n\n    features[scope] = createMap(names);\n  } else {\n    if (globalFeatures) {\n      throw new Error('Global features have already been initialized');\n    }\n\n    globalFeatures = createMap(names);\n  }\n\n  return featuring;\n};\n\n/**\n * Returns whether features for the specified <code>scope</code> have been initialized.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. <code>scope</code> is case\n * sensitive.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.initialized('example');\n * //=> false\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.initialized('example');\n * //=> true\n * featuring.initialized();\n * //=> false\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.initialized();\n * //=> true\n * </pre>\n * @param {string} [scope] - the scope to be checked (may be <code>null</code>, defaults to global/shared)\n * @return {boolean} <code>true</code> if <code>scope</code> has been initialized; otherwise <code>false</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.initialized = function(scope) {\n  return getMap(scope) != null;\n};\n\n/**\n * Returns all initialized scopes.\n *\n * This method will only return scopes that have been initialized, excluding the global/shared scope, which is not\n * represented by this method in any way, and does not care about whether those scopes contain any active features. It\n * is not guaranteed that the scopes will be returned in the same order in which they were passed to\n * {@link featuring.init}.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.scopes();\n * //=> []\n *\n * featuring.init([ 'FOO', 'BAR' ]);\n * featuring.init([ 'FU', 'BAZ' ], 'example');\n * featuring.init([], 'acme');\n *\n * featuring.scopes();\n * //=> [ \"example\", \"acme\" ]\n * </pre>\n *\n * @return {string[]} All initialized scopes.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.scopes = function() {\n  var scopes = [];\n\n  each(features, function(map, scope) {\n    scopes.push(scope);\n  });\n\n  return scopes;\n};\n\n/**\n * Returns a version of {@link featuring} that is bound (along with <i>all</i> of its methods) to the specified\n * <code>scope</code>.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code>. This method makes it super easy to do this so that applications are\n * free to use the global scope freely, unless a library/framework plans to package the featuring library within their\n * own distribution bundle so that it's only used by themselves. <code>scope</code> is case sensitive.\n *\n * Any scope passed to the methods within the returned wrapped API will be ignored in favor of <code>scope</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring').using('example');\n *\n * featuring.init([ 'FOO', 'BAR' ]);\n *\n * featuring.initialized();\n * //=> true\n * featuring('FOO').active();\n * //=> true\n * featuring.active([ 'FOO', 'BAR' ]);\n * //=> true\n * featuring.get();\n * //=> [ \"FOO\", \"BAR\" ]\n * featuring.verify([ 'FOO', 'BAR' ]);\n * featuring.when('BAR', function() {\n *   // ...\n * });\n * </pre>\n * @param {?string} scope - the scope to be used (may be <code>null</code>, defaults to global/shared)\n * @return {Function} A version of {@link featuring} that will, along with its methods, always use <code>scope</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.using = function(scope) {\n  var boundFeaturing = applyScope(featuring, scope);\n  applyScopeToAll(featuring, boundFeaturing, [\n    'active',\n    'anyActive',\n    'get',\n    'init',\n    'initialized',\n    'scopes',\n    'verify',\n    'verifyAny',\n    'when',\n    'whenAny'\n  ], scope);\n\n  boundFeaturing.active.any = boundFeaturing.anyActive;\n  boundFeaturing.using = featuring.using;\n  boundFeaturing.verify.any = boundFeaturing.verifyAny;\n  boundFeaturing.when.any = boundFeaturing.whenAny;\n\n  return boundFeaturing;\n};\n\n/**\n * Verifies that <b>all</b> of the named features are active within the specified <code>scope</code> and throws and\n * error if they are not.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method is useful for fail-fast sitations where you simply want your code to break when the named features are\n * not active.\n *\n * This method will throw an error unless <code>scope</code> has been initialized and contains all <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.verify('FOO', 'example');\n * featuring.verify([ 'FOO', 'BAR' ], 'example');\n * try {\n *   featuring.verify([ 'FOO', 'BUZZ' ], 'example');\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: \"BUZZ\" feature in \"example\" scope is not active\"\n * }\n * try {\n *   featuring.verify([ 'foo', 'bar' ], 'example');\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: \"foo\" feature in \"example\" scope is not active\"\n * }\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.verify([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.verify([]);\n * </pre>\n * @param {string|string[]} names - the names of the features to be verified\n * @param {string} [scope] - the scope in which the features are to be verified (may be <code>null</code>, defaults to\n * global/shared)\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @throws {Error} If any of the named features are not active.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.verify = function(names, scope) {\n  if (isString(names)) {\n    names = [ names ];\n  }\n\n  names.forEach(function(name) {\n    var feature = new Feature(name, scope);\n    feature.verify();\n  });\n\n  return featuring;\n};\n\n/**\n * Verifies that <b>any</b> of the named features are active within the specified <code>scope</code> and throws and\n * error if this is not the case.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method is useful for fail-fast sitations where you simply want your code to break when none of the named\n * features are active.\n *\n * This method will throw an error unless <code>scope</code> has been initialized and contains at least one of\n * <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.verify.any('FOO', 'example');\n * featuring.verify.any([ 'FOO', 'BAR' ], 'example');\n * featuring.verify.any([ 'FOO', 'BUZZ' ], 'example');\n * try {\n *   featuring.verify.any([ 'foo', 'bar' ], 'example');\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: No named features in \"example\" scope are active\"\n * }\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.verify.any([ 'FIZZ', 'BUZZ' ]);\n *\n * try {\n *   featuring.verify.any([]);\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: No named features in global scope are active\"\n * }\n * </pre>\n * @param {string|string[]} names - the names of the features to be verified\n * @param {string} [scope] - the scope in which the features are to be verified (may be <code>null</code>, defaults to\n * global/shared)\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @throws {Error} If all of the named features are not active.\n * @public\n * @static\n * @memberof featuring.verify\n */\nfeaturing.verify.any = function(names, scope) {\n  if (featuring.active.any(names, scope)) {\n    return featuring;\n  }\n\n  var formattedScope = isString(scope) ? '\"' + scope + '\"' : 'global';\n\n  throw new Error('No named features in ' + formattedScope + ' scope are active');\n};\n\n/**\n * An alias for the {@link featuring.verify.any} method.\n *\n * @param {string|string[]} names - the names of the features to be verified\n * @param {string} [scope] - the scope in which the features are to be verified (may be <code>null</code>, defaults to\n * global/shared)\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @throws {Error} If all of the named features are not active.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.verifyAny = featuring.verify.any;\n\n/**\n * Invokes the specified function only when <b>all</b> of the named features are active within the specified\n * <code>scope</code>.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method is often preferred over using {@link featuring.active} within an <code>if</code> expression when wrapping\n * large code. It helps prevent potential scoping issues (e.g. from variable hoisting) and can even be simpler to\n * replace with IIFEs, when taking that route.\n *\n * This method will only invoke <code>func</code> if <code>scope</code> has been initialized and contains all\n * <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.when('FOO', 'example', function() {\n *   // ...\n * });\n * featuring.when([ 'FOO', 'BAR' ], 'example', function() {\n *   // ...\n * });\n * featuring.when([ 'FOO', 'BUZZ' ], 'example', function() {\n *   // Never called\n * });\n * featuring.when([ 'foo', 'bar' ], 'example', function() {\n *   // Never called\n * });\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.when([ 'FIZZ', 'BUZZ' ], function() {\n *   // ...\n * });\n *\n * featuring.when([], function() {\n *   // ...\n * });\n * </pre>\n * @param {string|string[]} names - the names of the features to be active in order for <code>func</code> to be invoked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @param {Function} func - the function to be invoked when all named features are active or <code>names</code> is\n * empty.\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.when = function(names, scope, func) {\n  if (isFunction(scope)) {\n    func = scope;\n    scope = null;\n  }\n\n  if (featuring.active(names, scope)) {\n    func();\n  }\n\n  return featuring;\n};\n\n/**\n * Invokes the specified function only when <b>any</b> of the named features are active within the specified\n * <code>scope</code>.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method is often preferred over using {@link featuring.active.any} within an <code>if</code> expression when\n * wrapping large code. It helps prevent potential scoping issues (e.g. from variable hoisting) and can even be simpler\n * to replace with IIFEs, when taking that route.\n *\n * This method will only invoke <code>func</code> if <code>scope</code> has been initialized and contains at least one\n * of <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.when.any('FOO', 'example', function() {\n *   // ...\n * });\n * featuring.when.any([ 'FOO', 'BAR' ], 'example', function() {\n *   // ...\n * });\n * featuring.when.any([ 'FOO', 'BUZZ' ], 'example', function() {\n *   // ...\n * });\n * featuring.when.any([ 'foo', 'bar' ], 'example', function() {\n *   // Never called\n * });\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.when.any([ 'FIZZ', 'BUZZ' ], function() {\n *   // ...\n * });\n *\n * featuring.when.any([], function() {\n *   // Never called\n * });\n * </pre>\n * @param {string|string[]} names - the names of the features for which at least one must be active in order for\n * <code>func</code> to be invoked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @param {Function} func - the function to be invoked when any named feature is active.\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @public\n * @static\n * @memberof featuring.when\n */\nfeaturing.when.any = function(names, scope, func) {\n  if (isFunction(scope)) {\n    func = scope;\n    scope = null;\n  }\n\n  if (featuring.active.any(names, scope)) {\n    func();\n  }\n\n  return featuring;\n};\n\n/**\n * An alias for the {@link featuring.when.any} method.\n *\n * @param {string|string[]} names - the names of the features for which at least one must be active in order for\n * <code>func</code> to be invoked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @param {Function} func - the function to be invoked when any named feature is active.\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.whenAny = featuring.when.any;\n\n/**\n * Returns a function that delegates the call to the specified <code>func</code> so that the <code>scope</code>\n * provided is always passed to it.\n *\n * The returned function will always return the return value of calling <code>func</code>, unless it is\n * {@link featuring}, in which case <code>substitute</code> will be returned instead.\n *\n * @param {Function} func - the function to which <code>scope</code> is to be applied\n * @param {?string} scope - the scope to be applied (may be <code>null</code>, defaults to global/shared)\n * @param {*} substitute - the value to be returned if <code>func</code> returns a reference to {@link featuring} (may\n * be <code>null</code>)\n * @return {Function} A function which will always pass <code>scope</code> as the appropriate argument to\n * <code>func</code>.\n * @private\n */\nfunction applyScope(func, scope, substitute) {\n  return function() {\n    if (func.length === 1) {\n      return checkReturn(func(scope), substitute);\n    }\n\n    var names = arguments[0];\n    var rest = Array.prototype.slice.call(arguments, 1);\n\n    return checkReturn(func.apply(null, [ names, scope ].concat(rest)), substitute);\n  };\n}\n\n/**\n * Assigns functions to the specified <code>target</code> for all of the <code>names</code> provided that delegate their\n * calls to the function of the same name on the given <code>source</code> so that the <code>scope</code> provided is\n * always passed to them.\n *\n * Each proxy function will always return the return value of calling the original function, unless it is\n * {@link featuring}, in which case <code>target</code> will be returned instead.\n *\n * @param {Object} source - the object on which the original functions belong\n * @param {Object} target - the object to which the proxy functions are to be assigned\n * @param {string[]} names - the names of each function to be proxied\n * @param {?string} scope - the scope to be used (may be <code>null</code>, defaults to global/shared)\n * @return {void}\n * @private\n */\nfunction applyScopeToAll(source, target, names, scope) {\n  names.forEach(function(name) {\n    target[name] = applyScope(source[name], scope, target);\n  });\n}\n\n/**\n * Checks whether the specified return <code>value</code> of a proxied method if it is a reference to {@link featuring}\n * and, if so, returns the <code>substitute</code> instead.\n *\n * This method will simply return <code>value</code> if it does not reference {@link featuring}.\n *\n * @param {*} value - the return value to be checked (may be <code>null</code>)\n * @param {*} substitute - the value to be returned if <code>value</code> is a reference to {@link featuring} (may be\n * <code>null</code>)\n * @return {*} <code>value</code> unless it is a reference to {@link featuring}, in which case <code>substitute</code>.\n * @private\n */\nfunction checkReturn(value, substitute) {\n  return value === featuring ? substitute : value;\n}\n\n/**\n * Returns a feature mapping consisting of the specified <code>names</code>.\n *\n * This method simply constructs an object contain a property for each of the feature <code>names</code> whose value is\n * always <code>true</code>.\n *\n * The mapping is used instead of just array itself as hash lookups are much faster than searching arrays.\n *\n * @param {string|string[]} names - the names of all features to be included within the mapping\n * @return {Object.<string, boolean>} The feature mapping containing <code>names</code>.\n * @private\n */\nfunction createMap(names) {\n  if (isString(names)) {\n    names = [ names ];\n  }\n\n  var map = {};\n\n  names.forEach(function(name) {\n    map[name] = true;\n  });\n\n  return map;\n}\n\n/**\n * Iterators over the own key/value pairs within the specified object, invoking the <code>iterator</code> function\n * provided for each pair.\n *\n * @param {?Object} obj - the object whose key/value pairs are to be iterated over\n * @param {featuring~eachCallback} iterator - the function to be called with each key/value pair\n * @return {void}\n * @private\n */\nfunction each(obj, iterator) {\n  if (!obj) {\n    return;\n  }\n\n  for (var name in obj) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(obj, name)) {\n      iterator(obj[name], name, obj);\n    }\n  }\n}\n\n/**\n * Returns the appropriate feature mapping for the <code>scope</code> provided.\n *\n * If <code>scope</code> is <code>null</code>, this method will return the global/shared scope. Otherwise, it will\n * return the feature mapping for <code>scope</scope>.\n *\n * This method will return <code>null</code> if the target feature mapping has not been initialized.\n *\n * @param {?string} scope - the scope whose feature mapping is to be returned (may be <code>null</code> for\n * global/shared scope feature mapping)\n * @return {?Object.<string, boolean>} The feature mapping for <code>scope</code> or <code>null</code> if it has not\n * been initialized.\n * @private\n */\nfunction getMap(scope) {\n  return isString(scope) ? features[scope] : globalFeatures;\n}\n\n/**\n * Returns whether the specified object is a function.\n *\n * @param {*} obj - the object to be checked\n * @return {boolean} <code>true</code> if <code>obj</code> is a function; otherwise <code>false</code>.\n * @private\n */\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n\n/**\n * Returns whether the specified object is a string.\n *\n * @param {*} obj - the object to be checked\n * @return {boolean} <code>true</code> if <code>obj</code> is a string; otherwise <code>false</code>.\n * @private\n */\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n\nmodule.exports = featuring;\n\n/**\n * A function called for each key/value pair for an object.\n *\n * @callback featuring~eachCallback\n * @param {*} value - the value of the current property\n * @param {string} name - the name of the current property\n * @param {Object} obj - the object whose properties are being iterated over\n * @return {void}\n */\n","/*\n * Copyright (C) 2017 Alasdair Mercer, !ninja\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\nmodule.exports = require('./src/featuring');\n"],"names":["require$$0"],"mappings":"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"}