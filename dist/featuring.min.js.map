{"version":3,"file":"featuring.min.js","sources":["../src/featuring.js"],"sourcesContent":["/*\n * Copyright (C) 2017 Alasdair Mercer, !ninja\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\n/**\n * Contains feature mappings for each initialized scope.\n *\n * A feature mapping won't exist for a scope until {@link featuring.init} is called for it.\n *\n * @private\n * @type {Object.<string, Object.<string, boolean>>}\n */\nvar features = {};\n\n/**\n * Contains all features mapped to the global/shared scope.\n *\n * This will be <code>null</code> until {@link featuring.init} is called without a scope specified (or when it is\n * <code>null</code>).\n *\n * @private\n * @type {?Object.<string, boolean>}\n */\nvar globalFeatures = null;\n\n/**\n * Creates an instance of {@link Feature} for the specified <code>name</code> within the <code>scope</code> provided.\n *\n * <code>name</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * If <code>scope</code> is <code>null</code> it will default to a global/shared scope and, like <code>name</code>,\n * <code>scope</code> is case sensitive.\n *\n * @param {string} name - the name to be used\n * @param {?string} scope - the scope to be used (may be <code>null</code>, defaults to global/shared)\n * @private\n * @constructor\n */\nfunction Feature(name, scope) {\n  /**\n   * The name of this {@link Feature}.\n   *\n   * @private\n   * @type {string}\n   * @memberof Feature#\n   */\n  this._name = name;\n\n  /**\n   * The scope of this {@link Feature}.\n   *\n   * If <code>null</code>, the global/shared scope should be used.\n   *\n   * @private\n   * @type {?string}\n   * @memberof Feature#\n   */\n  this._scope = scope;\n}\n\nFeature.prototype = {\n\n  constructor: Feature,\n\n  /**\n   * Returns whether this {@link Feature} is active within its scope.\n   *\n   * This method will only return <code>true</code> if the scope for this {@link Feature} has been initialized and\n   * contains the name of this {@link Feature}.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring.init([ 'FOO', 'BAR' ], 'example');\n   *\n   * featuring('FOO', 'example').active();\n   * //=> true\n   * featuring('BAR', 'example').active();\n   * //=> true\n   * featuring('foo', 'example').active();\n   * //=> false\n   * featuring('FOO').active();\n   * //=> false\n   *\n   * featuring.init([ 'FIZZ', 'BUZZ' ]);\n   *\n   * featuring('FIZZ', 'example').active();\n   * //=> false\n   * featuring('BUZZ').active();\n   * //=> true\n   * </pre>\n   * @return {boolean} <code>true</code> if this {@link Feature} is active; otherwise <code>false</code>.\n   * @public\n   * @memberof Feature#\n   */\n  active: function() {\n    var target = getMap(this._scope);\n\n    return Boolean(target && target[this._name]);\n  },\n\n  /**\n   * Returns a version of this {@link Feature} that is bound to the specified <code>scope</code>.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring.init([ 'FOO', 'BAR' ], 'example');\n   *\n   * var feature = featuring('FOO');\n   *\n   * feature.active();\n   * //=> false\n   * feature.using('example').active();\n   * //=> true\n   * </pre>\n   * @param {?string} scope - the scope to be used (may be <code>null</code>, defaults to global/shared)\n   * @return {Feature} A version of this {@link Feature} for <code>scope</code>.\n   * @public\n   * @memberof Feature#\n   */\n  using: function(scope) {\n    return new Feature(this._name, scope);\n  },\n\n  /**\n   * Verifies that this {@link Feature} is active within its scope and throws and error if it is not.\n   *\n   * This method is useful for fail-fast sitations where you simply want your code to break when this {@link Feature} is\n   * not active.\n   *\n   * This {@link Feature} is only considered active if its scope has been initialized and contains its name.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring.init([ 'FOO', 'BAR' ], 'example');\n   *\n   * featuring('FOO', 'example').verify();\n   * try {\n   *   featuring('FIZZ', 'example').verify();\n   * } catch (error) {\n   *   console.error(error);\n   *   //=> \"Error: \"FIZZ\" feature in \"example\" scope is not active\"\n   * }\n   * </pre>\n   * @return {Feature} A reference to this {@link Feature} for chaining purposes.\n   * @throws {Error} If this {@link Feature} is not active.\n   * @public\n   * @memberof Feature#\n   */\n  verify: function() {\n    var formattedName, formattedScope;\n\n    if (!this.active()) {\n      formattedName = '\"' + this._name + '\"';\n      formattedScope = isString(this._scope) ? '\"' + this._scope + '\"' : 'global';\n\n      throw new Error(formattedName + ' feature in ' + formattedScope + ' scope is not active');\n    }\n\n    return this;\n  },\n\n  /**\n   * Invokes the specified function only when this {@link Feature} is active within its scope.\n   *\n   * This method is often preferred over using {@link Feature#active} within an <code>if</code> expression when wrapping\n   * large code. It helps prevent potential scoping issues (e.g. from variable hoisting) and can even be simpler to\n   * replace with IIFEs, when taking that route.\n   *\n   * This {@link Feature} is only considered active if its scope has been initialized and contains its name.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring.init([ 'FOO', 'BAR' ], 'example');\n   *\n   * featuring('FOO', 'example').when(function() {\n   *   // ...\n   * });\n   * featuring('BAR').when(function() {\n   *   // Never called\n   * });\n   * </pre>\n   * @param {Function} func - the function to be invoked when this {@link Feature} is active\n   * @return {Feature} A reference to this {@link Feature} for chaining purposes.\n   * @public\n   * @memberof Feature#\n   */\n  when: function(func) {\n    if (this.active()) {\n      func();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Returns a {@link Feature} for the specified <code>name</code> within the <code>scope</code> provided.\n *\n * <code>name</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>name</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method will <i>always</i> return an instance, even if <code>name</code> does not match a known/enabled feature,\n * as it is expected that the methods on the returned {@link Feature} instance will be used to check its state.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring('FOO', 'example').active();\n * //=> true\n * try {\n *   featuring('foo', 'example').verify();\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: \"foo\" feature in \"example\" scope is not active\"\n * }\n * featuring('BAR').when(function() {\n *   // Never called\n * });\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring('FIZZ', 'example').active();\n * //=> false\n * featuring('BUZZ').active();\n * //=> true\n *\n * featuring('BAR').using('example').active();\n * //=> true\n * </pre>\n * @param {string} name - the name of the feature\n * @param {string} [scope] - the scope of the feature (may be <code>null</code>, defaults to global/shared)\n * @return {Feature} A {@link Feature} for <code>name</code> and <code>scope</code>.\n * @public\n */\nfunction featuring(name, scope) {\n  return new Feature(name, scope);\n}\n\n/**\n * Returns whether <b>all</b> of the named features are active within the specified <code>scope</scope>.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method will only return <code>true</code> if <code>scope</code> has been initialized and contains all\n * <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.active('FOO', 'example');\n * //=> true\n * featuring.active([ 'FOO', 'BAR' ], 'example');\n * //=> true\n * featuring.active([ 'FOO', 'BUZZ' ], 'example');\n * //=> false\n * featuring.active([ 'foo', 'bar' ], 'example');\n * //=> false\n * featuring.active('FOO');\n * //=> false\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.active('FIZZ', 'example');\n * //=> false\n * featuring.active([ 'FIZZ', 'BUZZ' ]);\n * //=> true\n *\n * featuring.active([]);\n * //=> true\n * </pre>\n * @param {string|string[]} names - the names of the features to be checked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @return {boolean} <code>true</code> if all of the features are active or <code>names</code> is empty; otherwise\n * <code>false</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.active = function(names, scope) {\n  if (isString(names)) {\n    names = [ names ];\n  }\n\n  return names.every(function(name) {\n    var feature = new Feature(name, scope);\n\n    return feature.active();\n  });\n};\n\n/**\n * Returns whether <b>any</b> of the named features are active within the specified <code>scope</scope>.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method will return <code>true</code> if <code>scope</code> has been initialized and contains at least one of\n * <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.active.any('FOO', 'example');\n * //=> true\n * featuring.active.any([ 'FOO', 'BAR' ], 'example');\n * //=> true\n * featuring.active.any([ 'FOO', 'BUZZ' ], 'example');\n * //=> true\n * featuring.active.any([ 'foo', 'bar' ], 'example');\n * //=> false\n * featuring.active.any('FOO');\n * //=> false\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.active.any('FIZZ', 'example');\n * //=> false\n * featuring.active.any([ 'FIZZ', 'BUZZ' ]);\n * //=> true\n *\n * featuring.active.any([]);\n * //=> false\n * </pre>\n * @param {string|string[]} names - the names of the features to be checked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @return {boolean} <code>true</code> if any of the features are active; otherwise <code>false</code>.\n * @public\n * @static\n * @memberof featuring.active\n */\nfeaturing.active.any = function(names, scope) {\n  if (isString(names)) {\n    names = [ names ];\n  }\n\n  return names.some(function(name) {\n    var feature = new Feature(name, scope);\n\n    return feature.active();\n  });\n};\n\n/**\n * An alias for the {@link featuring.active.any} method.\n *\n * @param {string|string[]} names - the names of the features to be checked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @return {boolean} <code>true</code> if any of the features are active; otherwise <code>false</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.anyActive = featuring.active.any;\n\n/**\n * Returns the names of all of the active features within the specified <code>scope</scope>.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. <code>scope</code> is case\n * sensitive.\n *\n * This method will only return the names of features that are activie within <code>scope</code> if it has been\n * initialized. Otherwise, the returned array will be empty. It is not guaranteed that the feature names will be\n * returned in the same order in which they were passed to {@link featuring.init}.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.get('example');\n * //=> []\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.get('example');\n * //=> [ \"FOO\", \"BAR\" ]\n * featuring.get();\n * //=> []\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.get();\n * //=> [ \"FIZZ\", \"BUZZ\" ]\n * </pre>\n * @param {string} [scope] - the scope for which the names of all active features are to be returned (may be\n * <code>null</code>, defaults to global/shared)\n * @return {string[]} The names of all features active within <code>scope</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.get = function(scope) {\n  var target = getMap(scope);\n\n  return target ? getNames(target) : [];\n};\n\n/**\n * Initializes the specified <code>scope</code> with all of the named features.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * Obviously, this method should really be called before other methods, however, it can only be called once per scope.\n * Any attempts to initialize the same scope more than once will result in an error being thrown. This is done to\n * protect the immutability of the library. It's possible to check whether a scope has already been initialized via\n * {@link featuring.initialized}, if required to do so.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.active('FOO', 'example');\n * //=> false\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n * try {\n *   featuring.init([ 'FIZZ', 'BUZZ' ], 'example');\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: \"example\" scope features have already been initialized\"\n * }\n *\n * featuring.active([ 'FOO', 'BAR' ], 'example');\n * //=> true\n *\n * featuring.active('FIZZ');\n * //=> false\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n * try {\n *   featuring.init([ 'FOO', 'BAR' ]);\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: Global features have already been initialized\"\n * }\n *\n * featuring.active([ 'FIZZ', 'BUZZ' ]);\n * //=> true\n * </pre>\n * @param {string|string[]} names - the name of the features to be activated\n * @param {string} [scope] - the scope to be initialized with the active features (may be <code>null</code>, defaults to\n * global/shared)\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @throws {Error} If the features for <code>scope</code> have already been initialized.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.init = function(names, scope) {\n  if (isString(scope)) {\n    if (features[scope]) {\n      throw new Error('\"' + scope + '\" scope features have already been initialized');\n    }\n\n    features[scope] = createMap(names);\n  } else {\n    if (globalFeatures) {\n      throw new Error('Global features have already been initialized');\n    }\n\n    globalFeatures = createMap(names);\n  }\n\n  return featuring;\n};\n\n/**\n * Returns whether features for the specified <code>scope</code> have been initialized.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. <code>scope</code> is case\n * sensitive.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.initialized('example');\n * //=> false\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.initialized('example');\n * //=> true\n * featuring.initialized();\n * //=> false\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.initialized();\n * //=> true\n * </pre>\n * @param {string} [scope] - the scope to be checked (may be <code>null</code>, defaults to global/shared)\n * @return {boolean} <code>true</code> if <code>scope</code> has been initialized; otherwise <code>false</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.initialized = function(scope) {\n  return getMap(scope) != null;\n};\n\n/**\n * Returns a version of {@link featuring} that is bound (along with <i>all</i> of its methods) to the specified\n * <code>scope</code>.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code>. This method makes it super easy to do this so that applications are\n * free to use the global scope freely, unless a library/framework plans to package the featuring library within their\n * own distribution bundle so that it's only used by themselves. <code>scope</code> is case sensitive.\n *\n * Any scope passed to the methods within the returned wrapped API will be ignored in favor of <code>scope</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring').using('example');\n *\n * featuring.init([ 'FOO', 'BAR' ]);\n *\n * featuring.initialized();\n * //=> true\n * featuring('FOO').active();\n * //=> true\n * featuring.active([ 'FOO', 'BAR' ]);\n * //=> true\n * featuring.get();\n * //=> [ \"FOO\", \"BAR\" ]\n * featuring.verify([ 'FOO', 'BAR' ]);\n * featuring.when('BAR', function() {\n *   // ...\n * });\n * </pre>\n * @param {?string} scope - the scope to be used (may be <code>null</code>, defaults to global/shared)\n * @return {Function} A version of {@link featuring} that will, along with its methods, always use <code>scope</code>.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.using = function(scope) {\n  var boundFeaturing = applyScope(featuring, scope);\n  applyScopeToAll(featuring, boundFeaturing, [\n    'active',\n    'anyActive',\n    'get',\n    'init',\n    'initialized',\n    'verify',\n    'verifyAny',\n    'when',\n    'whenAny'\n  ], scope);\n\n  boundFeaturing.active.any = boundFeaturing.anyActive;\n  boundFeaturing.using = featuring.using;\n  boundFeaturing.verify.any = boundFeaturing.verifyAny;\n  boundFeaturing.when.any = boundFeaturing.whenAny;\n\n  return boundFeaturing;\n};\n\n/**\n * Verifies that <b>all</b> of the named features are active within the specified <code>scope</code> and throws and\n * error if they are not.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method is useful for fail-fast sitations where you simply want your code to break when the named features are\n * not active.\n *\n * This method will throw an error unless <code>scope</code> has been initialized and contains all <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.verify('FOO', 'example');\n * featuring.verify([ 'FOO', 'BAR' ], 'example');\n * try {\n *   featuring.verify([ 'FOO', 'BUZZ' ], 'example');\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: \"BUZZ\" feature in \"example\" scope is not active\"\n * }\n * try {\n *   featuring.verify([ 'foo', 'bar' ], 'example');\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: \"foo\" feature in \"example\" scope is not active\"\n * }\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.verify([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.verify([]);\n * </pre>\n * @param {string|string[]} names - the names of the features to be verified\n * @param {string} [scope] - the scope in which the features are to be verified (may be <code>null</code>, defaults to\n * global/shared)\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @throws {Error} If any of the named features are not active.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.verify = function(names, scope) {\n  if (isString(names)) {\n    names = [ names ];\n  }\n\n  names.forEach(function(name) {\n    var feature = new Feature(name, scope);\n    feature.verify();\n  });\n\n  return featuring;\n};\n\n/**\n * Verifies that <b>any</b> of the named features are active within the specified <code>scope</code> and throws and\n * error if this is not the case.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method is useful for fail-fast sitations where you simply want your code to break when none of the named\n * features are active.\n *\n * This method will throw an error unless <code>scope</code> has been initialized and contains at least one of\n * <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.verify.any('FOO', 'example');\n * featuring.verify.any([ 'FOO', 'BAR' ], 'example');\n * featuring.verify.any([ 'FOO', 'BUZZ' ], 'example');\n * try {\n *   featuring.verify.any([ 'foo', 'bar' ], 'example');\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: No named features in \"example\" scope are active\"\n * }\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.verify.any([ 'FIZZ', 'BUZZ' ]);\n *\n * try {\n *   featuring.verify.any([]);\n * } catch (error) {\n *   console.error(error);\n *   //=> \"Error: No named features in global scope are active\"\n * }\n * </pre>\n * @param {string|string[]} names - the names of the features to be verified\n * @param {string} [scope] - the scope in which the features are to be verified (may be <code>null</code>, defaults to\n * global/shared)\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @throws {Error} If all of the named features are not active.\n * @public\n * @static\n * @memberof featuring.verify\n */\nfeaturing.verify.any = function(names, scope) {\n  if (featuring.active.any(names, scope)) {\n    return featuring;\n  }\n\n  var formattedScope = isString(scope) ? '\"' + scope + '\"' : 'global';\n\n  throw new Error('No named features in ' + formattedScope + ' scope are active');\n};\n\n/**\n * An alias for the {@link featuring.verify.any} method.\n *\n * @param {string|string[]} names - the names of the features to be verified\n * @param {string} [scope] - the scope in which the features are to be verified (may be <code>null</code>, defaults to\n * global/shared)\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @throws {Error} If all of the named features are not active.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.verifyAny = featuring.verify.any;\n\n/**\n * Invokes the specified function only when <b>all</b> of the named features are active within the specified\n * <code>scope</code>.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method is often preferred over using {@link featuring.active} within an <code>if</code> expression when wrapping\n * large code. It helps prevent potential scoping issues (e.g. from variable hoisting) and can even be simpler to\n * replace with IIFEs, when taking that route.\n *\n * This method will only invoke <code>func</code> if <code>scope</code> has been initialized and contains all\n * <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.when('FOO', 'example', function() {\n *   // ...\n * });\n * featuring.when([ 'FOO', 'BAR' ], 'example', function() {\n *   // ...\n * });\n * featuring.when([ 'FOO', 'BUZZ' ], 'example', function() {\n *   // Never called\n * });\n * featuring.when([ 'foo', 'bar' ], 'example', function() {\n *   // Never called\n * });\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.when([ 'FIZZ', 'BUZZ' ], function() {\n *   // ...\n * });\n *\n * featuring.when([], function() {\n *   // ...\n * });\n * </pre>\n * @param {string|string[]} names - the names of the features to be active in order for <code>func</code> to be invoked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @param {Function} func - the function to be invoked when all named features are active or <code>names</code> is\n * empty.\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.when = function(names, scope, func) {\n  if (isFunction(scope)) {\n    func = scope;\n    scope = null;\n  }\n\n  if (featuring.active(names, scope)) {\n    func();\n  }\n\n  return featuring;\n};\n\n/**\n * Invokes the specified function only when <b>any</b> of the named features are active within the specified\n * <code>scope</code>.\n *\n * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including its case.\n *\n * <code>scope</code> is optional and will default to a global/shared scope, however, it is recommended that libraries\n * and frameworks always specify <code>scope</code> (which couldn't be easier via {@link featuring.using}) so that\n * applications are free to use the global scope freely, unless a library/framework plans to package the featuring\n * library within their own distribution bundle so that it's only used by themselves. Like <code>names</code>,\n * <code>scope</code> is case sensitive.\n *\n * This method is often preferred over using {@link featuring.active.any} within an <code>if</code> expression when\n * wrapping large code. It helps prevent potential scoping issues (e.g. from variable hoisting) and can even be simpler\n * to replace with IIFEs, when taking that route.\n *\n * This method will only invoke <code>func</code> if <code>scope</code> has been initialized and contains at least one\n * of <code>names</code>.\n *\n * @example\n * <pre>\n * var featuring = require('featuring');\n *\n * featuring.init([ 'FOO', 'BAR' ], 'example');\n *\n * featuring.when.any('FOO', 'example', function() {\n *   // ...\n * });\n * featuring.when.any([ 'FOO', 'BAR' ], 'example', function() {\n *   // ...\n * });\n * featuring.when.any([ 'FOO', 'BUZZ' ], 'example', function() {\n *   // ...\n * });\n * featuring.when.any([ 'foo', 'bar' ], 'example', function() {\n *   // Never called\n * });\n *\n * featuring.init([ 'FIZZ', 'BUZZ' ]);\n *\n * featuring.when.any([ 'FIZZ', 'BUZZ' ], function() {\n *   // ...\n * });\n *\n * featuring.when.any([], function() {\n *   // Never called\n * });\n * </pre>\n * @param {string|string[]} names - the names of the features for which at least one must be active in order for\n * <code>func</code> to be invoked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @param {Function} func - the function to be invoked when any named feature is active.\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @public\n * @static\n * @memberof featuring.when\n */\nfeaturing.when.any = function(names, scope, func) {\n  if (isFunction(scope)) {\n    func = scope;\n    scope = null;\n  }\n\n  if (featuring.active.any(names, scope)) {\n    func();\n  }\n\n  return featuring;\n};\n\n/**\n * An alias for the {@link featuring.when.any} method.\n *\n * @param {string|string[]} names - the names of the features for which at least one must be active in order for\n * <code>func</code> to be invoked\n * @param {string} [scope] - the scope in which the features are to be checked (may be <code>null</code>, defaults to\n * global/shared)\n * @param {Function} func - the function to be invoked when any named feature is active.\n * @return {Function} A reference to {@link featuring} for chaining purposes.\n * @public\n * @static\n * @memberof featuring\n */\nfeaturing.whenAny = featuring.when.any;\n\n/**\n * Returns a function that delegates the call to the specified <code>func</code> so that the <code>scope</code>\n * provided is always passed to it.\n *\n * The returned function will always return the return value of calling <code>func</code>.\n *\n * @param {Function} func - the function to which <code>scope</code> is to be applied\n * @param {?string} scope - the scope to be applied (may be <code>null</code>, defaults to global/shared)\n * @return {Function} A function which will always pass <code>scope</code> as the appropriate argument to\n * <code>func</code>.\n * @private\n */\nfunction applyScope(func, scope) {\n  return function() {\n    if (func.length === 1) {\n      return func(scope);\n    }\n\n    var names = arguments[0];\n    var rest = Array.prototype.slice.call(arguments, 1);\n\n    return func.apply(null, [ names, scope ].concat(rest));\n  };\n}\n\n/**\n * Assigns functions to the specified <code>target</code> for all of the <code>names</code> provided that delegate their\n * calls to the function of the same name on the given <code>source</code> so that the <code>scope</code> provided is\n * always passed to them.\n *\n * Each proxy function will always return the return value of calling the original function.\n *\n * @param {Object} source - the object on which the original functions belong\n * @param {Object} target - the object to which the proxy functions are to be assigned\n * @param {string[]} names - the names of each function to be proxied\n * @param {?string} scope - the scope to be used (may be <code>null</code>, defaults to global/shared)\n * @return {void}\n * @private\n */\nfunction applyScopeToAll(source, target, names, scope) {\n  names.forEach(function(name) {\n    target[name] = applyScope(source[name], scope);\n  });\n}\n\n/**\n * Returns a feature mapping consisting of the specified <code>names</code>.\n *\n * This method simply constructs an object contain a property for each of the feature <code>names</code> whose value is\n * always <code>true</code>.\n *\n * The mapping is used instead of just array itself as hash lookups are much faster than searching arrays.\n *\n * @param {string|string[]} names - the names of all features to be included within the mapping\n * @return {Object.<string, boolean>} The feature mapping containing <code>names</code>.\n * @private\n */\nfunction createMap(names) {\n  if (isString(names)) {\n    names = [ names ];\n  }\n\n  var map = {};\n\n  names.forEach(function(name) {\n    map[name] = true;\n  });\n\n  return map;\n}\n\n/**\n * Returns the appropriate feature mapping for the <code>scope</code> provided.\n *\n * If <code>scope</code> is <code>null</code>, this method will return the global/shared scope. Otherwise, it will\n * return the feature mapping for <code>scope</scope>.\n *\n * This method will return <code>null</code> if the target feature mapping has not been initialized.\n *\n * @param {?string} scope - the scope whose feature mapping is to be returned (may be <code>null</code> for\n * global/shared scope feature mapping)\n * @return {?Object.<string, boolean>} The feature mapping for <code>scope</code> or <code>null</code> if it has not\n * been initialized.\n * @private\n */\nfunction getMap(scope) {\n  return isString(scope) ? features[scope] : globalFeatures;\n}\n\n/**\n * Returns the names of the features within the specifed <code>map</code>.\n *\n * This method simply reduces <code>map</code> to an array of all enumeral own property names.\n *\n * @param {Object.<string, boolean>} map - the mapping whose feature names are to be returned\n * @return {string[]} The names of all features within <code>map</code>.\n * @private\n */\nfunction getNames(map) {\n  var names = [];\n\n  for (var key in map) {\n    if (Object.prototype.hasOwnProperty.call(map, key)) {\n      names.push(key);\n    }\n  }\n\n  return names;\n}\n\n/**\n * Returns whether the specified object is a function.\n *\n * @param {*} obj - the object to be checked\n * @return {boolean} <code>true</code> if <code>obj</code> is a function; otherwise <code>false</code>.\n * @private\n */\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n\n/**\n * Returns whether the specified object is a string.\n *\n * @param {*} obj - the object to be checked\n * @return {boolean} <code>true</code> if <code>obj</code> is a string; otherwise <code>false</code>.\n * @private\n */\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n\nmodule.exports = featuring;\n"],"names":["Feature","name","scope","this","_name","_scope","featuring","applyScope","func","length","names","arguments","rest","Array","prototype","slice","call","apply","concat","applyScopeToAll","source","target","forEach","createMap","isString","map","getMap","features","globalFeatures","getNames","key","Object","hasOwnProperty","push","isFunction","obj","constructor","active","Boolean","using","verify","formattedName","formattedScope","Error","when","every","any","some","anyActive","get","init","initialized","boundFeaturing","verifyAny","whenAny"],"mappings":"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"}