{"version":3,"file":"featuring.min.js","sources":["../src/featuring.js"],"sourcesContent":["/*\n * Copyright (C) 2018 Alasdair Mercer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\n/**\n  * Encapsulates the named active <code>features</code> provided, allowing them to be queried at any time while\n  * preventing them from being modified.\n  *\n  * It is important to remember that <code>features</code> are case sensitive, so subsequent calls to methods on the\n  * returned instance must <b>exactly</b> match that in which it appears within <code>features</code>.\n  *\n  * @example\n  * <pre>\n  * var features = require('featuring')([ 'FOO', 'BAR' ]);\n  *\n  * features.active('FOO');\n  * //=> true\n  * features.active([ 'FOO', 'BUZZ' ]);\n  * //=> false\n  * features.anyActive([ 'FOO', 'BAR' ]);\n  * //=> true\n  *\n  * features.get();\n  * //=> [ \"FOO\", \"BAR\" ]\n  *\n  * features.verify('FOO');\n  * // ...\n  * features.verify([ 'FOO', 'BUZZ' ]);\n  * //=> Error(\"BUZZ\" feature is not active)\n  * features.verifyAny([ 'FOO', 'BAR' ]);\n  * // ...\n  *\n  * features.when('FOO', function() {\n  *   // ...\n  * });\n  * features.when([ 'FOO', 'BUZZ' ], function() {\n  *   // Never called\n  * });\n  * features.whenAny([ 'FOO', 'BAR' ], function() {\n  *   // ...\n  * });\n  * </pre>\n  * @param {string|string[]} [features] - the names of the features to be active (may be <code>null</code>)\n  * @public\n  * @constructor\n  */\nfunction Featuring(features) {\n  if (!(this instanceof Featuring)) {\n    return new Featuring(features);\n  }\n\n  features = sanitizeNames(features).slice();\n\n  /**\n   * A reference to this instance.\n   *\n   * @private\n   * @type {Featuring}\n   */\n  var self = this;\n\n  /**\n   * A map containing all active features.\n   *\n   * @private\n   * @type {Object.<string, boolean>}\n   */\n  var map = {};\n\n  features.forEach(function(name) {\n    map[name] = true;\n  });\n\n  /**\n   * Returns whether <b>all</b> of the named features are active.\n   *\n   * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including their case.\n   *\n   * @example\n   * <pre>\n   * var features = require('featuring')([ 'FOO', 'BAR' ]);\n   *\n   * features.active('FOO');\n   * //=> true\n   * features.active('BUZZ');\n   * //=> false\n   * features.active([ 'FOO', 'BAR' ]);\n   * //=> true\n   * features.active([ 'FOO', 'BUZZ' ]);\n   * //=> false\n   * features.active([ 'foo', 'bar' ]);\n   * //=> false\n   *\n   * features.active(null);\n   * //=> true\n   * features.active([]);\n   * //=> true\n   * </pre>\n   * @param {string|string[]} [names] - the names of the features to be checked (may be <code>null</code>)\n   * @return {boolean} <code>true</code> if all of the named features are active or <code>names</code> is\n   * <code>null</code> or empty; otherwise <code>false</code>.\n   * @public\n   * @memberof Featuring#\n   */\n  self.active = function(names) {\n    return sanitizeNames(names).every(function(name) {\n      return isActive(map, name);\n    });\n  };\n\n  /**\n   * Returns whether <b>any</b> of the named features are active.\n   *\n   * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including their case.\n   *\n   * This method can also be accessed via {@link Featuring#active.any}.\n   *\n   * @example\n   * <pre>\n   * var features = require('featuring')([ 'FOO', 'BAR' ]);\n   *\n   * features.anyActive('FOO');\n   * //=> true\n   * features.anyActive('BUZZ');\n   * //=> false\n   * features.anyActive([ 'FOO', 'BAR' ]);\n   * //=> true\n   * features.anyActive([ 'FOO', 'BUZZ' ]);\n   * //=> true\n   * features.anyActive([ 'foo', 'bar' ]);\n   * //=> false\n   *\n   * features.anyActive(null);\n   * //=> false\n   * features.anyActive([]);\n   * //=> false\n   * </pre>\n   * @param {string|string[]} [names] - the names of the features to be checked (may be <code>null</code>)\n   * @return {boolean} <code>true</code> if any of the named features are active; otherwise <code>false</code>.\n   * @public\n   * @memberof Featuring#\n   */\n  self.anyActive = self.active.any = function(names) {\n    return sanitizeNames(names).some(function(name) {\n      return isActive(map, name);\n    });\n  };\n\n  /**\n   * Returns the names of all of the active features.\n   *\n   * @example\n   * <pre>\n   * var featuring = require('featuring');\n   *\n   * featuring([]).get();\n   * //=> []\n   * featuring('FOO').get();\n   * //=> [ \"FOO\" ]\n   * featuring([ 'FOO', 'BAR' ]).get();\n   * //=> [ \"FOO\", \"BAR\" ]\n   * </pre>\n   * @return {string[]} The names of all active features.\n   * @public\n   * @memberof Featuring#\n   */\n  self.get = function() {\n    return features.slice();\n  };\n\n  /**\n   * Verifies that <b>all</b> of the named features are active and throws an error if they are not.\n   *\n   * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including their case.\n   *\n   * This method is useful for fail-fast situations where it's best if the code simply breaks when the named features\n   * are not active.\n   *\n   * @example\n   * <pre>\n   * var features = require('featuring')([ 'FOO', 'BAR' ]);\n   *\n   * features.verify('FOO');\n   * // ...\n   * features.verify('BUZZ');\n   * //=> Error(\"BUZZ\" feature is not active)\n   * features.verify([ 'FOO', 'BAR' ]);\n   * //=> ...\n   * features.verify([ 'FOO', 'BUZZ' ]);\n   * //=> Error(\"BUZZ\" feature is not active)\n   * features.verify([ 'foo', 'bar' ]);\n   * //=> Error(\"foo\" feature is not active)\n   *\n   * features.verify(null);\n   * // ...\n   * features.verify([]);\n   * // ...\n   * </pre>\n   * @param {string|string[]} [names] - the names of the features to be verified (may be <code>null</code>)\n   * @return {Featuring} A reference to this instance for chaining purposes.\n   * @throws {Error} If any of the named features are not active.\n   * @public\n   * @memberof Featuring#\n   */\n  self.verify = function(names) {\n    sanitizeNames(names).forEach(function(name) {\n      verifyActive(map, name);\n    });\n\n    return self;\n  };\n\n  /**\n   * Verifies that <b>any</b> of the named features are active and throws an error if this is not the case.\n   *\n   * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including their case.\n   *\n   * This method is useful for fail-fast situations where it's best if the code simply breaks when none of the named\n   * features are active.\n   *\n   * This method can also be accessed via {@link Featuring#verify.any}.\n   *\n   * @example\n   * <pre>\n   * var features = require('featuring')([ 'FOO', 'BAR' ]);\n   *\n   * features.verifyAny('FOO');\n   * // ...\n   * features.verifyAny('BUZZ');\n   * //=> Error(All named features are not active)\n   * features.verifyAny([ 'FOO', 'BAR' ]);\n   * //=> ...\n   * features.verifyAny([ 'FOO', 'BUZZ' ]);\n   * // ...\n   * features.verifyAny([ 'foo', 'bar' ]);\n   * //=> Error(All named features are not active)\n   *\n   * features.verifyAny(null);\n   * //=> Error(All named features are not active)\n   * features.verifyAny([]);\n   * //=> Error(All named features are not active)\n   * </pre>\n   * @param {string|string[]} [names] - the names of the features to be verified (may be <code>null</code>)\n   * @return {Featuring} A reference to this instance for chaining purposes.\n   * @throws {Error} If all of the named features are not active  or <code>names</code> is <code>null</code> or empty.\n   * @public\n   * @memberof Featuring#\n   */\n  self.verifyAny = self.verify.any = function(names) {\n    if (self.anyActive(names)) {\n      return self;\n    }\n\n    throw new Error('All named features are not active');\n  };\n\n  /**\n   * Invokes the specified function only when <b>all</b> of the named features are active.\n   *\n   * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including their case.\n   *\n   * This method is often preferred over using {@link Featuring#active} within an <code>if</code> expression when\n   * wrapping large code as it helps to prevent potential scoping issues (e.g. from variable hoisting) and can even be\n   * simpler to replace with IIFEs, when taking that route.\n   *\n   * @example\n   * <pre>\n   * var features = require('featuring')([ 'FOO', 'BAR' ]);\n   *\n   * features.when('FOO', function() {\n   *   // ...\n   * });\n   * features.when('BUZZ', function() {\n   *   // Never called\n   * });\n   * features.when([ 'FOO', 'BAR' ], function() {\n   *   // ...\n   * });\n   * features.when([ 'FOO', 'BUZZ' ], function() {\n   *   // Never called\n   * });\n   * features.when([ 'foo', 'bar' ], function() {\n   *   // Never called\n   * });\n   *\n   * features.when(null, function() {\n   *   // ...\n   * });\n   * features.when([], function() {\n   *   // ...\n   * });\n   * </pre>\n   * @param {string|string[]} [names] - the names of the features to be active in order for <code>func</code> to be\n   * invoked (may be <code>null</code>)\n   * @param {Function} func - the function to be invoked when all named features are active or <code>names</code> is\n   * <code>null</code> or empty\n   * @return {Featuring} A reference to this instance for chaining purposes.\n   * @public\n   * @memberof Featuring#\n   */\n  self.when = function(names, func) {\n    if (typeof names === 'function') {\n      func = names;\n      names = null;\n    }\n\n    if (self.active(names)) {\n      func();\n    }\n\n    return self;\n  };\n\n  /**\n   * Invokes the specified function only when <b>any</b> of the named features are active.\n   *\n   * Each item within <code>names</code> must <b>exactly</b> match that of the known feature, including their case.\n   *\n   * This method is often preferred over using {@link Featuring#anyActive} within an <code>if</code> expression when\n   * wrapping large code as it helps to prevent potential scoping issues (e.g. from variable hoisting) and can even be\n   * simpler to replace with IIFEs, when taking that route.\n   *\n   * This method can also be accessed via {@link Featuring#when.any}.\n   *\n   * @example\n   * <pre>\n   * var features = require('featuring')([ 'FOO', 'BAR' ]);\n   *\n   * features.whenAny('FOO', function() {\n   *   // ...\n   * });\n   * features.whenAny('BUZZ', function() {\n   *   // Never called\n   * });\n   * features.whenAny([ 'FOO', 'BAR' ], function() {\n   *   // ...\n   * });\n   * features.whenAny([ 'FOO', 'BUZZ' ], function() {\n   *   // ...\n   * });\n   * features.whenAny([ 'foo', 'bar' ], function() {\n   *   // Never called\n   * });\n   *\n   * features.whenAny(null, function() {\n   *   // Never called\n   * });\n   * features.whenAny([], function() {\n   *   // Never called\n   * });\n   * </pre>\n   * @param {string|string[]} [names] - the names of the features for which at least one must be active in order for\n   * <code>func</code> to be invoked (may be <code>null</code>)\n   * @param {Function} func - the function to be invoked when any named feature is active\n   * @return {Featuring} A reference to this instance for chaining purposes.\n   * @public\n   * @memberof Featuring#\n   */\n  self.whenAny = self.when.any = function(names, func) {\n    if (typeof names === 'function') {\n      func = names;\n      names = null;\n    }\n\n    if (self.anyActive(names)) {\n      func();\n    }\n\n    return self;\n  };\n}\n\n/**\n * Returns whether the feature with the specified <code>name</code> is active within the <code>map</code> provided.\n *\n * @param {Object.<string, boolean>} map - the feature mapping in which <code>name</code> is to be checked\n * @param {string} name - the name of the feature to be checked\n * @return {boolean} <code>true</code> if the named feature is active in <code>map</code>; otherwise <code>false</code>.\n * @private\n */\nfunction isActive(map, name) {\n  return Boolean(map[name]);\n}\n\n/**\n * Sanitizes the specified feature <code>names</code> so that they can be consumed easily by the API.\n *\n * This method ensures that, regardless of which format <code>names</code> was passed to the API, it will be consumed as\n * an array of strings.\n *\n * @param {?string|string[]} names - the feature names to be sanitized (may be <code>null</code>)\n * @return {string[]} The santized feature <code>names</code>.\n * @private\n */\nfunction sanitizeNames(names) {\n  if (names == null) {\n    return [];\n  }\n\n  if (typeof names === 'string') {\n    return [ names ];\n  }\n\n  return names;\n}\n\n/**\n * Verifies that the feature with the specified <code>name</code> is active within the <code>map</code> provided and\n * throws an error if it is not.\n *\n * @param {Object.<string, boolean>} map - the feature mapping in which <code>name</code> is to be checked\n * @param {string} name - the name of the feature to be verified\n * @return {void}\n * @throws {Error} If the named feature is not active in <code>map</code>.\n * @private\n */\nfunction verifyActive(map, name) {\n  if (!isActive(map, name)) {\n    throw new Error('\"' + name + '\" feature is not active');\n  }\n}\n\nmodule.exports = Featuring;\n"],"names":["isActive","map","name","Boolean","sanitizeNames","names","Featuring","features","this","slice","self","forEach","active","every","anyActive","any","some","get","verify","Error","verifyActive","verifyAny","when","func","whenAny"],"mappings":";iMAgZA,SAASA,EAASC,EAAKC,GACrB,OAAOC,QAAQF,EAAIC,IAarB,SAASE,EAAcC,GACrB,OAAa,MAATA,EACK,GAGY,iBAAVA,EACF,CAAEA,GAGJA,SArWT,SAASC,EAAUC,GACjB,KAAMC,gBAAgBF,GACpB,OAAO,IAAIA,EAAUC,GAGvBA,EAAWH,EAAcG,GAAUE,QAQnC,IAAIC,EAAOF,KAQPP,EAAM,GAEVM,EAASI,QAAQ,SAAST,GACxBD,EAAIC,IAAQ,IAkCdQ,EAAKE,OAAS,SAASP,GACrB,OAAOD,EAAcC,GAAOQ,MAAM,SAASX,GACzC,OAAOF,EAASC,EAAKC,MAoCzBQ,EAAKI,UAAYJ,EAAKE,OAAOG,IAAM,SAASV,GAC1C,OAAOD,EAAcC,GAAOW,KAAK,SAASd,GACxC,OAAOF,EAASC,EAAKC,MAsBzBQ,EAAKO,IAAM,WACT,OAAOV,EAASE,SAqClBC,EAAKQ,OAAS,SAASb,GAKrB,OAJAD,EAAcC,GAAOM,QAAQ,SAAST,IAmN1C,SAAsBD,EAAKC,GACzB,IAAKF,EAASC,EAAKC,GACjB,MAAM,IAAIiB,MAAM,IAAMjB,EAAO,2BApN3BkB,CAAanB,EAAKC,KAGbQ,GAuCTA,EAAKW,UAAYX,EAAKQ,OAAOH,IAAM,SAASV,GAC1C,GAAIK,EAAKI,UAAUT,GACjB,OAAOK,EAGT,MAAM,IAAIS,MAAM,sCA+ClBT,EAAKY,KAAO,SAASjB,EAAOkB,GAU1B,MATqB,mBAAVlB,IACTkB,EAAOlB,EACPA,EAAQ,MAGNK,EAAKE,OAAOP,IACdkB,IAGKb,GAgDTA,EAAKc,QAAUd,EAAKY,KAAKP,IAAM,SAASV,EAAOkB,GAU7C,MATqB,mBAAVlB,IACTkB,EAAOlB,EACPA,EAAQ,MAGNK,EAAKI,UAAUT,IACjBkB,IAGKb"}